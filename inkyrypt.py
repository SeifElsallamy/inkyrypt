from hashlib import sha512
#converts string to list of bits
def string_to_bits(s):
    result = []
    for c in s:
        bits = bin(ord(c))[2:]
        bits = '00000000'[len(bits):] + bits
        result.extend([int(b) for b in bits])
    return result
#converts list of bits to string
def bits_to_string(bits):
    chars = []
    for b in range(len(bits) / 8):
        byte = bits[b*8:(b+1)*8]
        chars.append(chr(int(''.join([str(bit) for bit in byte]), 2)))
    return ''.join(chars)
#returns the result of XORing 2 lists of bits
def xor(x1,x2):
    x=[]
    if len(x1) != len(x2):
        print "x1 and x2 not same length"
        return False
    for i in range(len(x1)):
        x.append(x1[i] ^ x2[i])
    return x

def key_pad(string_to_expand, length):
   return (string_to_expand * ((length/len(string_to_expand))+1))[:length]
#Encryptor
def enc(f,k):
    
    f = f + sha512(f).hexdigest()
    #Add signature to the file
    diff = len(f) - len(k)
    #Calculate the diffrents in length between the key and the file content
    #Both key and file content must be equal in length in order to xor (encrypt) them to generate the cipher 
    if diff > 0:
        k = k + key_pad(k, diff)
        # if needs more key lengths add more key length by repeating the key
    if diff < 0:
        k = k[:len(f)]
        #if it needs less key remove part from the key
    #convert the file content and the key to list bits
    f = string_to_bits(f)
    k = string_to_bits(k)
    #return the xor result
    return xor(f,k)
#Decryptor  
def dec(f,k):
    #This part is useless however removing it will cause bugs and I'm too lazy it will just generate another signature 
    f = f + sha512(f).hexdigest()
    diff = len(f) - len(k)
    if diff > 0:
        k = k + key_pad(k, diff)
    if diff < 0:
        k = k[:len(f)]
    
    f = string_to_bits(f)
    k = string_to_bits(k)
    
    m = xor(f,k)
    #Decrypt the message
    m = bits_to_string(m)[:-128]
    #removing the useless signature (generated by the first couple of lines )
    sign = m[-128:]
    #Extracting the signature 
    m = m[:-128]
    #Extracting the file content
    verify = sha512(m).hexdigest()
    #verifying the signature and returning the result
    if sign == verify:
        return m
    return False
     



e_or_d = raw_input("Write 'e' for Encrypt or 'd' Decrypt  :\n")
 
x=raw_input("Enter file path:\n").strip()
#x=x[:-1].replace("'","").replace("\\","/")
with open(x,"rb") as f:
    c = f.read()
    
p=raw_input("Enter password to (Decrypt/Encrypt):\n")

k = sha512(p).hexdigest()
#Hashing the password with SHA512
if e_or_d == 'e':
    c=enc(c,k)
    with open(x,"wb") as f:
        f.write(bits_to_string(c))
    
if e_or_d == 'd':
    m=dec(c,k)
    
    if m:
        with open(x,"wb") as f:
            f.write(m)
            
    else:
        print "Wrong password!!!"    






